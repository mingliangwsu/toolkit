# -*- coding: utf-8 -*-
"""accessSSURGO.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_rvK8KGkXK4sGFvuvXR687LW66uYL836
"""
import requests
import random
from shapely.geometry import Polygon, Point
from shapely import wkt
from collections import Counter

def fetch_sdm_data(query):
    # Define the endpoint URL for the SDM API
    endpoint = "https://SDMDataAccess.sc.egov.usda.gov/Tabular/post.rest"

    # Set the payload with the SQL query
    payload = {
        'QUERY': query,
        'FORMAT': 'JSON'
    }

    try:
        # Send the POST request to the API
        response = requests.post(endpoint, data=payload)

        # Check if the request was successful (status code 200)
        if response.status_code == 200:
            # Parse the JSON response
            data = response.json()
            if 'Table' in data:
                return data['Table']
            else:
                return None
        else:
            print("Error fetching data:", response.status_code, response.text)
            return None
    except requests.exceptions.RequestException as e:
        print("Error:", e)
        return None

def print_nested_list_structure(nested_list, level=0):
    indent = "  " * level
    if isinstance(nested_list, list):
        print(f"{indent}Level {level} - Length: {len(nested_list)}")
        for sublist in nested_list:
            print_nested_list_structure(sublist, level + 1)

def print_nested_types(nested_structure, level=0):
    indent = "  " * level
    if level == 0:
        print(nested_structure)
    if isinstance(nested_structure, list):
        print(f"{indent}Level {level}: list with length {len(nested_structure)}")
        for sublist in nested_structure:
            print_nested_types(sublist, level + 1)
    elif isinstance(nested_structure, dict):
        print(f"{indent}Level {level}: dict with length {len(nested_structure)}")
        for key, value in nested_structure.items():
            print(f"{indent}  Key: {key}")
            print_nested_types(value, level + 1)
    else:
        print(f"{indent}Level {level}: {type(nested_structure).__name__}")

def get_mukey_muname_from_geocoordinate(plon,plat):
    query = f"""
    SELECT mukey AS MUKEY, muname AS Map_unit_name
    FROM mapunit
    WHERE mukey IN (SELECT * from SDA_Get_Mukey_from_intersection_with_WktWgs84('point ({plon} {plat})'))
    """
    result = fetch_sdm_data(query)
    if result:
      return result[0][0],result[0][1],100.0
    else:
      return None,None,None

"""#Soil texture with Farmland Class"""

# Function to generate random points within the polygon
def generate_random_points(polygon, num_points=10):
    min_x, min_y, max_x, max_y = polygon.bounds
    points = []
    while len(points) < num_points:
        # Generate random point within the bounding box
        random_point = Point(random.uniform(min_x, max_x), random.uniform(min_y, max_y))
        # Check if the point is within the polygon
        if polygon.contains(random_point):
            points.append(random_point)
    return points

def get_dominant_mukey_muname_from_polygon(wkt_polygon, num_points=10):
    #Use Monte Carlo method to identify dominent mukey
    #return dominent mukey,name,percent
    
    #SELECT mukey AS MUKEY, muname AS Map_unit_name
    # Convert WKT string to Shapely Polygon object
    polygon = wkt.loads(wkt_polygon)
    # Generate 10 random points within the polygon
    random_points = generate_random_points(polygon, num_points)
    # Print the coordinates of the random points
    mukeys = list()
    mykey_names = dict()
    for i, point in enumerate(random_points, 1):
        mk,mn,pc = get_mukey_muname_from_geocoordinate(point.x,point.y)
        #print(f"Point {i}: {point.x}, {point.y} mukey:{mk} mukey_name:{mn}")
        if mk != None:
            mukeys.append(mk)
            mykey_names[mk] = mn
    if len(mukeys) > 0:
        dominent_mukey = Counter(mukeys).most_common(1)[0][0]
        return dominent_mukey,mykey_names[dominent_mukey],100.0*Counter(mukeys).most_common(1)[0][1]/num_points
    else:
        return None,None, None


from re import M
import pandas as pd
pd.set_option('display.max_columns', None)
def get_all_components_soil_properties(mukey):
    #return a dataframe (NOTE: all value are text format)

    #farmlndcl： Identification of map units as prime farmland, farmland of statewide importance, or farmland of local importance
    #comppct: (%)
    #elev: (m)
    #wthirdbar: (%) The volumetric content of soil water retained at a tension of 1/3 bar (33 kPa), expressed as a percentage of the whole soil
    #wfifteenbar: (%) The volumetric content of soil water retained at a tension of 15 bars (1500 kPa), expressed as a percentage of the whole soil
    #wsatiated: (%) The estimated volumetric soil water content at or near zero bar tension, expressed as a percentage of the whole soil
    #awc： (fraction) The amount of water that an increment of soil depth, inclusive of fragments, can store that is available to plants. AWC is expressed as a volume fraction
    #ksat: (um/s) The amount of water that would move vertically through a unit area of saturated soil in unit time under unit hydraulic gradient
    #hzdept: (cm) The distance from the top of the soil to the upper boundary of the soil horizon
    #hzdepb: (cm) The distance from the top of the soil to the base of the soil horizon
    #sandtotal: (%) Mineral particles 0.05mm to 2.0mm in equivalent diameter as a weight percentage of the less than 2 mm fraction
    #silttotal: (%) Mineral particles 0.002 to 0.05mm in equivalent diameter as a weight percentage of the less than 2.0mm fraction
    #claytotal: (%) Mineral particles less than 0.002mm in equivalent diameter as a weight percentage of the less than 2.0mm fraction
    #om: (%) The amount by weight of decomposed plant and animal residue expressed as a weight percentage of the less than 2 mm soil material
    #partdensity: (g/cm3) Mass per unit of volume (not including pore space) of the solid soil particle either mineral or organic. Also known as specific gravity
    #dbthirdbar: (g/cm3) The oven dry weight of the less than 2 mm soil material per unit volume of soil at a water tension of 1/3 bar
    #dbfifteenbar: (g/cm3) The oven dry weight of the less than 2 mm soil material per unit volume of soil at a water tension of 15 bar
    #texdesc: The full texture description for a horizon, using full texture class and in lieu of names rather than abbreviations
    #texture: Name for the concatenation of TEXTURE_MODIFIER and TEXTURE_CLASS
    #texcl: An expression, based on the USDA system of particle sizes, for the relative portions of the various size groups of individual mineral grains less than 2mm equivalent diameter in a mass of soil

    query = f"""
    SELECT
    muname, mu.mukey, farmlndcl, -- attributes from table "mapunit"
    comppct_r, compname, elev_r, wthirdbar_r, wfifteenbar_r, wsatiated_r, awc_r, ksat_r, drainagecl,   -- attributes from table "component"
    hzdept_r, hzdepb_r, ch.chkey, -- attributes from table "chorizon"
    sandtotal_r, silttotal_r, claytotal_r, om_r, partdensity, dbthirdbar_r, dbfifteenbar_r, --total sand, silt and clay fractions from table "chorizon"
    sandvc_r, sandco_r, sandmed_r, sandfine_r, sandvf_r, --sand sub-fractions from table "chorizon"
    texdesc, texture, -- attributes from table "chtexturegrp"
    texcl -- attributes from table "chtexture"
    FROM sacatalog sac
    INNER JOIN legend l ON l.areasymbol = sac.areasymbol AND l.areatypename = 'Non-MLRA Soil Survey Area'
    INNER JOIN mapunit mu ON mu.lkey = l.lkey
    AND mu.mukey IN ('{mukey}')
    LEFT OUTER JOIN component c ON c.mukey = mu.mukey
    LEFT OUTER JOIN chorizon ch ON ch.cokey = c.cokey
    LEFT OUTER JOIN chtexturegrp chtgrp ON chtgrp.chkey = ch.chkey
    LEFT OUTER JOIN chtexture cht ON cht.chtgkey = chtgrp.chtgkey
    ORDER BY comppct_r DESC, hzdept_r ASC
    """
    vars = ["muname", "mu.mukey", "farmlndcl", "comppct_r", "compname", "elev_r", "wthirdbar_r",
            "wfifteenbar_r", "wsatiated_r", "awc_r", "ksat_r", "drainagecl", "hzdept_r",
            "hzdepb_r", "ch.chkey", "sandtotal_r", "silttotal_r", "claytotal_r", "om_r",
            "partdensity", "dbthirdbar_r", "dbfifteenbar_r", "sandvc_r", "sandco_r",
            "sandmed_r", "sandfine_r", "sandvf_r", "texdesc", "texture", "texcl"]

    result = fetch_sdm_data(query)
    #print(len(result[0]))
    #return result
    if result:
        df = pd.DataFrame(result, columns=vars)
        return df
    else:
      return None

"""
#plon,plat = -117.1387,46.7374  #Pullman
#plon,plat = -119.8268,46.7193  #CRB
#plon,plat = -120.45403,46.97644  #YKB
plon,plat = -120.45332,46.97603  #YKB
mukey,muname = get_mukey_muname_from_geocoordinate(plon,plat)
print(f'{mukey}:{muname}')
result = get_all_components_soil_properties(mukey)
#print(result[["comppct_r", "compname","ch.chkey","hzdept_r","hzdepb_r","texdesc"]])
print(result)
"""

#Linear interpolation
"""
from scipy.interpolate import interp1d
import matplotlib.pyplot as plt

x = [0, 1, 2]
y = [1, 3, 2]
f = interp1d(x, y)
y_hat = f(2)
print(y_hat)
"""
